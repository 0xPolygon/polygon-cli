package modes

import (
	"context"
	cryptorand "crypto/rand"
	"crypto/sha256"
	"fmt"
	"math/big"
	"math/rand"
	"time"

	"github.com/0xPolygon/polygon-cli/loadtest/config"
	"github.com/0xPolygon/polygon-cli/loadtest/mode"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto/kzg4844"
	"github.com/ethereum/go-ethereum/params"
	"github.com/holiman/uint256"
	"github.com/rs/zerolog/log"
)

func init() {
	mode.Register(&BlobMode{})
}

// BlobMode implements blob transaction sending.
type BlobMode struct{}

func (m *BlobMode) Name() string {
	return "blob"
}

func (m *BlobMode) Aliases() []string {
	return []string{"b"}
}

func (m *BlobMode) RequiresContract() bool {
	return false
}

func (m *BlobMode) RequiresERC20() bool {
	return false
}

func (m *BlobMode) RequiresERC721() bool {
	return false
}

func (m *BlobMode) Init(ctx context.Context, cfg *config.Config, deps *mode.Dependencies) error {
	return nil
}

func (m *BlobMode) Execute(ctx context.Context, cfg *config.Config, deps *mode.Dependencies, tops *bind.TransactOpts) (start, end time.Time, txHash common.Hash, err error) {
	to := cfg.ToETHAddress
	if cfg.RandomRecipients {
		to = mode.GetRandomAddress(deps)
	}

	amount := cfg.SendAmount
	chainID := new(big.Int).SetUint64(cfg.ChainID)

	gasLimit := uint64(21000)
	blobFeeCap := cfg.BlobFeeCap

	// Blob transactions require EIP-1559 support
	if tops.GasFeeCap == nil || tops.GasTipCap == nil {
		err = fmt.Errorf("blob transactions require EIP-1559 support (non-legacy mode)")
		log.Error().Err(err).Msg("Cannot send blob transaction in legacy mode")
		return
	}

	// Initialize blobTx with blob transaction type
	blobTx := types.BlobTx{
		ChainID:    uint256.NewInt(chainID.Uint64()),
		Nonce:      tops.Nonce.Uint64(),
		GasTipCap:  uint256.NewInt(tops.GasTipCap.Uint64()),
		GasFeeCap:  uint256.NewInt(tops.GasFeeCap.Uint64()),
		BlobFeeCap: uint256.NewInt(blobFeeCap),
		Gas:        gasLimit,
		To:         *to,
		Value:      uint256.NewInt(amount.Uint64()),
		Data:       nil,
		AccessList: nil,
		BlobHashes: make([]common.Hash, 0),
		Sidecar: &types.BlobTxSidecar{
			Blobs:       make([]kzg4844.Blob, 0),
			Commitments: make([]kzg4844.Commitment, 0),
			Proofs:      make([]kzg4844.Proof, 0),
		},
	}

	err = appendBlobCommitment(&blobTx)
	if err != nil {
		log.Error().Err(err).Msg("Unable to parse blob")
		return
	}
	tx := types.NewTx(&blobTx)

	stx, err := tops.Signer(tops.From, tx)
	if err != nil {
		log.Error().Err(err).Msg("Unable to sign transaction")
		return
	}

	txHash = stx.Hash()

	start = time.Now()
	defer func() { end = time.Now() }()

	if cfg.EthCallOnly {
		log.Error().Err(err).Msg("CallOnly not supported for blob transactions")
		return
	} else if cfg.OutputRawTxOnly {
		err = mode.OutputRawTransaction(stx)
	} else {
		err = deps.Client.SendTransaction(ctx, stx)
	}
	return
}

// generateRandomBlobData generates random data for blob encoding.
func generateRandomBlobData(size int) ([]byte, error) {
	data := make([]byte, size)
	n, err := cryptorand.Read(data)
	if err != nil {
		return nil, err
	}
	if n != size {
		return nil, fmt.Errorf("could not create random blob data with size %d: %v", size, err)
	}
	return data, nil
}

// createBlob takes in randomly generated byte slice and commits it with KZG.
func createBlob(data []byte) kzg4844.Blob {
	blob := kzg4844.Blob{}
	fieldIndex := -1
	for i := 0; i < len(data); i += 31 {
		fieldIndex++
		if fieldIndex == params.BlobTxFieldElementsPerBlob {
			break
		}
		max := min(i+31, len(data))
		copy(blob[fieldIndex*32+1:], data[i:max])
	}
	return blob
}

// blobCommitment holds blob transaction commitment data.
type blobCommitment struct {
	Blob          kzg4844.Blob
	Commitment    kzg4844.Commitment
	Proof         kzg4844.Proof
	VersionedHash common.Hash
}

// generateBlobCommitment generates the values for BlobCommitment variables.
func generateBlobCommitment(data []byte) (*blobCommitment, error) {
	dataLen := len(data)
	if dataLen > params.BlobTxFieldElementsPerBlob*(params.BlobTxBytesPerFieldElement-1) {
		return nil, fmt.Errorf("blob data longer than allowed (length: %v, limit: %v)", dataLen, params.BlobTxFieldElementsPerBlob*(params.BlobTxBytesPerFieldElement-1))
	}
	bc := blobCommitment{
		Blob: createBlob(data),
	}
	var err error

	// Generate blob commitment
	bc.Commitment, err = kzg4844.BlobToCommitment(&bc.Blob)
	if err != nil {
		return nil, fmt.Errorf("failed generating blob commitment: %w", err)
	}

	// Generate blob proof
	bc.Proof, err = kzg4844.ComputeBlobProof(&bc.Blob, bc.Commitment)
	if err != nil {
		return nil, fmt.Errorf("failed generating blob proof: %w", err)
	}

	// Build versioned hash
	bc.VersionedHash = sha256.Sum256(bc.Commitment[:])
	bc.VersionedHash[0] = 0x01
	return &bc, nil
}

// appendBlobCommitment appends blob commitment data to a blob transaction.
func appendBlobCommitment(tx *types.BlobTx) error {
	var err error
	var blobBytes []byte
	var blobRefBytes []byte
	blobLen := rand.Intn((params.BlobTxFieldElementsPerBlob * (params.BlobTxBytesPerFieldElement - 1)) - len(blobBytes))
	blobRefBytes, _ = generateRandomBlobData(blobLen)

	if blobRefBytes == nil {
		return fmt.Errorf("unknown blob ref")
	}
	blobBytes = append(blobBytes, blobRefBytes...)

	bc, err := generateBlobCommitment(blobBytes)
	if err != nil {
		return fmt.Errorf("invalid blob: %w", err)
	}

	tx.BlobHashes = append(tx.BlobHashes, bc.VersionedHash)
	tx.Sidecar.Blobs = append(tx.Sidecar.Blobs, bc.Blob)
	tx.Sidecar.Commitments = append(tx.Sidecar.Commitments, bc.Commitment)
	tx.Sidecar.Proofs = append(tx.Sidecar.Proofs, bc.Proof)
	return nil
}
