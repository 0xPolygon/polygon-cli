package loadtest

import (
	"encoding/hex"
	"io"
	"math/rand"

	"github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
)

// hexwordReader provides a reader that generates hex-word patterns.
type hexwordReader struct {
	randSrc *rand.Rand
}

var hexwords = []byte{
	0x00, 0x0F, 0xF1, 0xCE,
	0x00, 0xBA, 0xB1, 0x0C,
	0x1B, 0xAD, 0xB0, 0x02,
	0x8B, 0xAD, 0xF0, 0x0D,
	0xAB, 0xAD, 0xBA, 0xBE,
	0xB1, 0x05, 0xF0, 0x0D,
	0xB1, 0x6B, 0x00, 0xB5,
	0x0B, 0x00, 0xB1, 0x35,
	0xBA, 0xAA, 0xAA, 0xAD,
	0xBA, 0xAD, 0xF0, 0x0D,
	0xBA, 0xD2, 0x22, 0x22,
	0xBA, 0xDD, 0xCA, 0xFE,
	0xCA, 0xFE, 0xB0, 0xBA,
	0xB0, 0xBA, 0xBA, 0xBE,
	0xBE, 0xEF, 0xBA, 0xBE,
	0xC0, 0x00, 0x10, 0xFF,
	0xCA, 0xFE, 0xBA, 0xBE,
	0xCA, 0xFE, 0xD0, 0x0D,
	0xCE, 0xFA, 0xED, 0xFE,
	0x0D, 0x15, 0xEA, 0x5E,
	0xDA, 0xBB, 0xAD, 0x00,
	0xDE, 0xAD, 0x2B, 0xAD,
	0xDE, 0xAD, 0xBA, 0xAD,
	0xDE, 0xAD, 0xBA, 0xBE,
	0xDE, 0xAD, 0xBE, 0xAF,
	0xDE, 0xAD, 0xBE, 0xEF,
	0xDE, 0xAD, 0xC0, 0xDE,
	0xDE, 0xAD, 0xDE, 0xAD,
	0xDE, 0xAD, 0xD0, 0x0D,
	0xDE, 0xAD, 0xFA, 0x11,
	0xDE, 0xAD, 0x10, 0xCC,
	0xDE, 0xAD, 0xFE, 0xED,
	0xDE, 0xCA, 0xFB, 0xAD,
	0xDE, 0xFE, 0xC8, 0xED,
	0xD0, 0xD0, 0xCA, 0xCA,
	0xE0, 0x11, 0xCF, 0xD0,
	0xFA, 0xCE, 0xFE, 0xED,
	0xFB, 0xAD, 0xBE, 0xEF,
	0xFE, 0xE1, 0xDE, 0xAD,
	0xFE, 0xED, 0xBA, 0xBE,
	0xFE, 0xED, 0xC0, 0xDE,
	0xFF, 0xBA, 0xDD, 0x11,
	0xF0, 0x0D, 0xBA, 0xBE,
}

// NewHexwordReader creates a new hexword reader with the given random source.
func NewHexwordReader(randSrc *rand.Rand) io.Reader {
	return &hexwordReader{randSrc: randSrc}
}

func (h *hexwordReader) Read(p []byte) (n int, err error) {
	for i := range p {
		p[i] = hexwords[h.randSrc.Intn(len(hexwords))]
	}
	return len(p), nil
}

// GetRandomAddress generates a random Ethereum address.
func GetRandomAddress(randSrc *rand.Rand) *common.Address {
	addr := make([]byte, 20)
	_, _ = randSrc.Read(addr)
	ethAddr := common.BytesToAddress(addr)
	return &ethAddr
}

// OutputRawTransaction outputs a raw signed transaction as hex.
func OutputRawTransaction(tx *ethtypes.Transaction) error {
	rawTx, err := tx.MarshalBinary()
	if err != nil {
		return err
	}
	return OutputRawBytes(rawTx)
}

// OutputRawBytes outputs raw bytes as a 0x-prefixed hex string.
func OutputRawBytes(rawTx []byte) error {
	println("0x" + hex.EncodeToString(rawTx))
	return nil
}
