package mode

import (
	"encoding/hex"
	"fmt"
	"io"

	"github.com/0xPolygon/polygon-cli/loadtest/config"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

// hexwords are used for generating test data.
var hexwords = []byte{
	0x00, 0x0F, 0xF1, 0xCE,
	0x00, 0xBA, 0xB1, 0x0C,
	0x1B, 0xAD, 0xB0, 0x02,
	0x8B, 0xAD, 0xF0, 0x0D,
	0xAB, 0xAD, 0xBA, 0xBE,
	0xB1, 0x05, 0xF0, 0x0D,
	0xB1, 0x6B, 0x00, 0xB5,
	0x0B, 0x00, 0xB1, 0x35,
	0xBA, 0xAA, 0xAA, 0xAD,
	0xBA, 0xAD, 0xF0, 0x0D,
	0xBA, 0xD2, 0x22, 0x22,
	0xBA, 0xDD, 0xCA, 0xFE,
	0xCA, 0xFE, 0xB0, 0xBA,
	0xB0, 0xBA, 0xBA, 0xBE,
	0xBE, 0xEF, 0xBA, 0xBE,
	0xC0, 0x00, 0x10, 0xFF,
	0xCA, 0xFE, 0xBA, 0xBE,
	0xCA, 0xFE, 0xD0, 0x0D,
	0xCE, 0xFA, 0xED, 0xFE,
	0x0D, 0x15, 0xEA, 0x5E,
	0xDA, 0xBB, 0xAD, 0x00,
	0xDE, 0xAD, 0x2B, 0xAD,
	0xDE, 0xAD, 0xBA, 0xAD,
	0xDE, 0xAD, 0xBA, 0xBE,
	0xDE, 0xAD, 0xBE, 0xAF,
	0xDE, 0xAD, 0xBE, 0xEF,
	0xDE, 0xAD, 0xC0, 0xDE,
	0xDE, 0xAD, 0xDE, 0xAD,
	0xDE, 0xAD, 0xD0, 0x0D,
	0xDE, 0xAD, 0xFA, 0x11,
	0xDE, 0xAD, 0x10, 0xCC,
	0xDE, 0xAD, 0xFE, 0xED,
	0xDE, 0xCA, 0xFB, 0xAD,
	0xDE, 0xFE, 0xC8, 0xED,
	0xD0, 0xD0, 0xCA, 0xCA,
	0xE0, 0x11, 0xCF, 0xD0,
	0xFA, 0xCE, 0xFE, 0xED,
	0xFB, 0xAD, 0xBE, 0xEF,
	0xFE, 0xE1, 0xDE, 0xAD,
	0xFE, 0xED, 0xBA, 0xBE,
	0xFE, 0xED, 0xC0, 0xDE,
	0xFF, 0xBA, 0xDD, 0x11,
	0xF0, 0x0D, 0xBA, 0xBE,
}

// HexwordReader provides a reader that generates hex-word patterns.
type HexwordReader struct {
	deps *Dependencies
}

// NewHexwordReader creates a new hexword reader with the given random source.
func NewHexwordReader(deps *Dependencies) io.Reader {
	return &HexwordReader{deps: deps}
}

func (h *HexwordReader) Read(p []byte) (n int, err error) {
	h.deps.RandSourceMu.Lock()
	defer h.deps.RandSourceMu.Unlock()
	for i := range p {
		p[i] = hexwords[h.deps.RandSource.Intn(len(hexwords))]
	}
	return len(p), nil
}

// GetRandomAddress generates a random Ethereum address using the given random source.
func GetRandomAddress(deps *Dependencies) *common.Address {
	addr := make([]byte, 20)
	_, _ = deps.RandRead(addr)
	ethAddr := common.BytesToAddress(addr)
	return &ethAddr
}

// OutputRawTransaction outputs a raw signed transaction as hex.
func OutputRawTransaction(tx *types.Transaction) error {
	rawTx, err := tx.MarshalBinary()
	if err != nil {
		return err
	}
	return OutputRawBytes(rawTx)
}

// OutputRawBytes outputs raw bytes as a 0x-prefixed hex string to stdout.
func OutputRawBytes(rawTx []byte) error {
	fmt.Println("0x" + hex.EncodeToString(rawTx))
	return nil
}

// TxToCallMsg converts a transaction to an ethereum.CallMsg.
func TxToCallMsg(cfg *config.Config, tx *types.Transaction) ethereum.CallMsg {
	cm := new(ethereum.CallMsg)
	cm.From = *cfg.FromETHAddress
	cm.To = tx.To()
	cm.Gas = tx.Gas()
	cm.GasPrice = tx.GasPrice()
	cm.GasFeeCap = tx.GasFeeCap()
	cm.GasTipCap = tx.GasTipCap()
	cm.Value = tx.Value()
	cm.Data = tx.Data()
	cm.AccessList = tx.AccessList()
	return *cm
}

// TransactOptsToCallMsg converts bind.TransactOpts to an ethereum.CallMsg.
func TransactOptsToCallMsg(cfg *config.Config, gasLimit uint64) ethereum.CallMsg {
	cm := new(ethereum.CallMsg)
	cm.From = *cfg.FromETHAddress
	cm.Gas = gasLimit
	return *cm
}
